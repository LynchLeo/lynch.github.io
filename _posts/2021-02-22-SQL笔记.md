---
layout:     post
title:      数据库系统
subtitle:   数据库的基本概念，关系查询语言（Relational Query Languages）
date:       2021-02-22
author:     LynchLeo
header-img: img/post-web.jpg
catalog: true
tags:
    - SQL
---

下文所用SQL在线网站：
[https://www.db-book.com/db7/university-lab-dir/sqljs.html](https://www.db-book.com/db7/university-lab-dir/sqljs.html)

参考网站：
[https://taogenjia.com/2019/10/24/database-system-1-introduction/](https://taogenjia.com/2019/10/24/database-system-1-introduction/)

# 数据（Data）

## 数据抽象（Data Abstraction）

* 从最低到最高：
  * 物理层（Physical Level）专注于数据的实际格式和位置
  * 逻辑层（Logical Level）侧重于数据的含义，内容和上下文
  * 视图层（View Level）专注于简化与系统的交互

## 逻辑视图（Logic View）

* 数据按组或类别进行组织
* 字段（Field）：一系列相关的字符
* 记录（Record）：一系列相关的字段
  * 例：一个人的姓名、年龄及身份证号
* 表（Table）：一系列相关的记录
* 数据库（Database）：基于关系模型的，一系列相关的表

## 主键（Key Field / Primary Key）

* 唯一标识符（Unique Identifier）
* 用于创建表之间的关系，将数据集成到数据库中

## 批处理（Batch Processing）与实时处理（Real-Time Processing）

* 在批处理中，在几个小时，几天甚至几周内收集数据，然后统一进行处理
  * 例：月底一次性处理的信用卡账单
* 在实时处理中，数据一旦产生就立刻进行处理

# 数据库（Database）

## 数据库的优点

* 共享（Sharing）
* 安全（Security）：访问受限
* 减少数据冗余（Less Data Redundancy）：减少不必要的重复
* 数据完整性（Data Integrity）：减少数据不正确的可能性
  * 一个人的货物发送到他的新地址，但帐单发给了他的旧地址，这很可能归因于数据完整性不足

> 可靠性（Reliability）不是使用数据库的优势

## 数据库管理系统（Database Management System / DBMS）

* 用于创建、修改和访问数据库的软件
* 由相互关联的数据的集合和访问该数据的程序的集合组成
* 包含五个子系统：
  * DBMS引擎（DBMS Engine）提供了逻辑层和物理层之间的桥梁
  * 数据定义子系统（Data Definition Subsystem）使用数据字典（Data Dictionary）或模式（Schema）定义数据库的逻辑结构
  * 数据处理子系统（Data Manipulation Subsystem）提供了用于数据维护和数据分析的工具，如示例查询（Query by Example / QBE）和结构化查询语言（Structured Query Language / SQL）
  * 应用程序生成子系统（Application Generation Subsystem）提供了使用专用编程语言创建数据输入表单的工具
  * 数据管理子系统（Data Administration Subsystem）管理数据库
    * 数据库管理员（Database Administrators / DBAs）是计算机专业人员，可以帮助定义数据库中数据的处理权限和访问权限

## 常见数据库模型（Common Database Models）

* 分层数据库（Hierarchical Database）
  * 结构化的字段或记录存储在节点（Node）中
    * 一对多关系
      * 每个节点一个父级
      * 父级可以有几个子节点
  * 主要问题是，如果父节点被删除，那么所有从属子节点也会被删除

* 网络数据库（Network Database）
  * 分层节点排列
    * 多对多关系
      * 每个子节点可能有多个父节点   
  * 节点之间的其他连接是指针
  * 节点可以通过多条路径到达

* 关系型数据库（Relational Database）
  * 一种更灵活的类型，其中在层次结构下没有访问路径
    * 表中存储的数据称为关系（Relation）
    * 表由行和列组成
    * 通过主键关联的表
  * 拥有嫌疑人的驾照号码的警察可以使用关系数据库来跟踪其家庭住址

* 多维数据库（Multidimensional Database）
  * 关系型数据库的变化和扩展
  * 包括一个数据立方体
    * 扩展二维数据模型以包括附加或多维
  * 非常适合表示复杂的关系
  * 与关系数据库相比的优势：
    * 概念化为用户提供了一个直观的模型，其中可以将复杂的数据和关系概念化
    * 分析和查询大型多维数据库的处理速度更快

* 面向对象的数据库（Object-Oriented Database）
  * 存储数据以及操作数据的指令
  * 组织数据使用：
    * 类（Classes）
    * 对象（Objects）：类的特定实例，包含数据和操作数据的指令
    * 属性（Attributes）：对象拥有的数据字段
    * 方法（Methods）：检索或操作属性值的说明 

## 数据库类型

* 个人或个人计算机数据库（Individual or Personal Computer Database）
   * 仅一人使用的集成文件
   * 数据和DBMS存储在用户的硬盘驱动器或LAN文件服务器上
* 公司数据库（Company Database）
   * 组织中共享常用操作或常用文件
* 分布式数据库（Distributed Database）
   * 数据库在地理上分布并使用数据库服务器进行访问
* 商业或信息实用程序或数据库（Commercial or Information Utilities or Data Banks）
   * 组织为涵盖特定主题而开发的庞大数据库

## 实例（Instances）和模式（Schemas）

* 逻辑模式（Logical Schema）：数据库的整体逻辑结构，类似于程序中变量的类型信息
  * 示例：数据库包含有关银行中一组客户和帐户以及它们之间的关系的信息 
* 物理模式（Physical Schema）：数据库的整体物理结构
* 实例：特定时间点数据库的实际内容，类似于变量
* 物理数据独立性（Physical Data Independence）：无需更改逻辑架构即可修改物理架构的能力
  * 应用程序取决于逻辑模式
  * 通常，应明确定义各个级别和组件之间的接口，以便某些部分的更改不会严重影响其他部分
  * 如果数据的存储结构或访问技术有所更改，则不必相应地重新编写和重新编译应用程序

## 数据定义语言（Data Definition Language / DDL）

* 定义数据库模式和数据的属性

     例：

```sql
        create table instructor (
               ID          char(5),
               name        varchar(20),
               dept_name   varchar(20),
               salary      numeric(8,2))
```

* DDL编译器生成一组存储在数据字典中的表模板
* 数据字典包含元数据（Metadata）
  * 数据库模式
  * 诚信约束
    * 主键
  * 授权

## 数据操纵语言（Data Manipulation Language / DML）

* 访问和更新由适当的数据模型组织的数据
* 基本上有两种类型的数据操纵语言：
  * 程序式（Procedural）DML：要求用户指定所需的数据，以及如何获取这些数据。
  * 声明式（Declarative）DML：要求用户指定所需的数据，而不指定如何获取这些数据。
  * 声明式DML也称为非程序式DML，通常比程序式DML更易于学习和使用
* DML中涉及信息检索的部分称为查询语言（Query Language）

## SQL查询语言（SQL Query Language）

* SQL查询语言是非程序式的。查询将多个表（可能只有一个）作为输入，并且始终返回单个表
* 例：查找 Sci. dept的所有讲师

```sql
    SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';
```

* SQL不是图灵机等效语言（Turing Machine Equivalent Language）
* 为了能够计算复杂的函数，SQL通常嵌入到某些高级语言中
* 应用程序通常通过以下方式之一访问数据库
   * 语言扩展允许嵌入式SQL
   * 应用程序接口（如ODBC / JDBC）允许将SQL查询发送到数据库

## 数据库设计（Database Disign）

设计数据库一般架构的过程：

* 逻辑设计：决定数据库模式。数据库设计要求我们找到关系模式的“良好”集合
   * 商业决策：我们应该在数据库中记录哪些属性
   * 计算机科学决策：我们应该拥有哪些关系模式，以及如何在各种关系模式之间分配属性
* 物理设计：确定数据库的物理布局

## 数据库引擎（Database Engine）

* 数据库系统分为多个模块，分别处理整个系统的各项职责
* 数据库系统的功能组件可以分为：
   * 存储管理器（Storage Manager）
   * 查询处理器组件
   * 交易管理组件

## 存储管理器（Storage Manager）

* 程序模块，提供数据库中存储的低级数据与提交给系统的应用程序和查询之间的接口
* 存储管理器负责以下任务：
   * 与OS文件管理器的交互
   * 高效地存储、检索和更新数据
* 存储管理器组件包括：
   * 授权和完整性管理器（Authorization and Integrity Manager）
   * 事务管理器（Transaction Manager）
   * 文件管理器（File Manager）
   * 缓存管理器（Buffer Manager）
* 存储管理器实现了几种数据结构，这是物理系统实现的一部分：
   * 数据文件（Data File）：存储数据库本身
   * 数据字典（Data Dictionary）：存储有关数据库结构，特别是数据库架构的元数据
   * 索引（Index）：可以提供对数据项的快速访问。 数据库索引提供了指向具有特定值的那些数据项的指针

## 查询处理器（Query Processor）

* 查询处理器组件包括：
  * DDL解释器：解释DDL语句，并将定义记录在数据字典中
  * DML编译器：将查询语言中的DML语句转换为评估计划，该评估计划由查询评估引擎可以理解的低级指令组成
    * DML编译器执行查询优化；也就是说，它从各种备选方案中选择成本最低的评估计划
  * 查询评估引擎：执行DML编译器生成的低级指令

## 事务管理（Transaction Management）

* 事务是在数据库应用程序中执行单个逻辑功能的操作的集合
  * 事务管理组件（Transaction-management component）可确保即使发生系统故障（例如电源故障和操作系统崩溃）和事务故障，数据库仍保持一致（正确）状态
  * 并发控制管理器（Concurrency-Control Manager）控制并发事务之间的交互，以确保数据库的一致性
* 数据库系统维护ACID属性：
  * 原子性（Atomicity）。事务的所有操作都正确地反映在数据库中，或者没有反映
  * 一致性（Consistency）。隔离执行事务（也就是说，没有其他事务同时执行）可以保持数据库的一致性
  * 隔离（Isolation）。即使可以同时执行多个事务，系统也会保证每个事务都不知道系统中同时执行的其他事务
  * 耐用性（Durability）。事务成功完成后，即使系统出现故障，对数据库所做的更改也会保留

## 数据库架构（Database Architecture）

* 数据库系统的架构很大程度上受到运行数据库的基础计算机系统的影响：
  * 集中式数据库
    * 一对核心，共享内存
  * 客户端服务器
    * 一台服务器计算机代表多台客户端计算机执行工作
  * 并行数据库
    * 多核共享内存
    * 共享磁盘
    * 没有分享
  * 分布式数据库
    * 地理分布
    * 模式/数据异构

## 数据库应用程序（Database Applications）

数据库应用程序通常分为两部分或三部分

* 两层体系结构（Two-Tier Architecture）：应用程序驻留在客户端计算机上，调用在服务器计算机上的数据库系统功能
  * 应用程序和DBMS不在同一台计算机上
* 三层体系结构（Three-Tier Architecture）：客户端计算机充当前端，不包含任何直接的数据库调用
  * 客户端通常通过表单接口与应用服务器通信
  * 应用服务器又与数据库系统通信以访问数据
* 在两层体系结构中，前端直接与在后端运行的数据库进行通信，而在三层体系结构中，后端部分本身被分解为应用服务器和数据库服务器

## 数据库管理员（Database Administrator / DBA）

对系统具有中央控制权的人称为数据库管理员。DBA的功能包括：

* 模式定义
* 存储结构和访问方法定义
* 模式和物理组织修改
* 授予数据访问授权
* 例行维修
* 定期备份数据库
* 确保有足够的可用磁盘空间用于正常操作，并根据需要升级磁盘空间
* 监视数据库上运行的作业

> DBA可以使用应用程序生成子系统创建用户表单和菜单

## 数据库系统的历史

* 1950年代和1960年代初期：
  * 使用磁带进行数据处理以进行存储
    * 磁带仅提供顺序访问
  * 打孔卡输入
* 1960年代末和1970年代：
  * 硬盘允许直接访问数据
  * 广泛使用网络和分层数据模型
  * Ted Codd定义了关系数据模型
    * 这项工作将获得ACM图灵奖
    * IBM Research开始System R原型
    * 加州大学伯克利分校的Michael Stonebraker开始Ingres原型
    * Oracle发布第一个商业关系数据库
  * 高性能（在当时）事务处理
* 1980年代：
  * 研究型关系原型发展为商业系统
    * SQL成为工业标准
  * 并行和分布式数据库系统
    * Wisconsin，IBM，Teradata
  * 面向对象的数据库系统
* 1990年代：
  * 大型决策支持和数据挖掘应用程序
  * 大型的多TB数据仓库
  * 网络商务的出现
* 2000年代
  * 大数据存储系统
    * Google BigTable，Yahoo PNuts，Amazon
    * “NoSQL”系统
  * 大数据分析：超越SQL
    * Map reduce and friends
* 2010年代
  * SQL已重装
    * Map Reduce系统的SQL前端
    * 大规模并行数据库系统
    * 多核主内存数据库

## 关系模式和实例（Relation Schema and Instance）

* A1，A2，…，An是属性（Attribute）
  * 每个属性的允许值集称为属性的域
  * 属性值（通常）是原子的，也就是说，不可分割
  * 特殊值null是每个域的成员，表示该值是“未知”或“不存在”
  * 空值会导致许多操作的定义复杂化
* R =（A1，A2，…，An）是一个关系模式
  * 例：instructor = (ID, name, dept_name, salary)
  * 在模式R上定义的关系实例r用r（R）表示。
  * 关系的当前值由表格指定
* 关系r的元素t称为元组（Tuple），并由表中的一行表示
  * 元组的顺序无关紧要（元组可以按任意顺序存储）

## 数据库模式

* 数据库模式是数据库的逻辑结构
   *例：instructor (ID, name, dept_name, salary)
* 数据库实例是在给定时间瞬间数据库中数据的快照

## 键（Keys）

* 令K为R的子集，如果K的值足以识别每个可能关系r（R）的唯一元组，则K是R的主键
   * 例：{ID}和{ID，name}都是instructor的主键。
* 如果K最小，则主键K是候选键（Candidate Key）
   * 例：{ID}是instructor的候选键
* 选择一个候选键作为主键
* 外键约束（Foreign Key Constraint）：一个关系中的值必须出现在另一个关系中
   * 引用关系，被引用关系
   * 例：instructor中的dept_name是department的外键

> 所有关系都有候选键

```sql
employee (person_name, street, city)
works (person_name, company_name, salary)
company (company_name, city)
```

* 例：考虑关系数据库。适当的主键是什么？
   * 答案：person_name, person_name, company_name

# 关系查询语言（Relational Query Languages）

* 查询语言是用户从数据库中请求信息的语言。
* 可以分为命令式，功能式或声明式
   * 命令式（Imperative）：用户指示系统对数据库执行特定的操作序列以计算所需的结果
   * 功能式（Functional）：计算表示为对可能对数据库中的数据或其他功能的结果进行操作的功能的评估
   * 声明式（Declarative）：用户描述所需的信息，而没有给出获取该信息的特定步骤或函数调用顺序
* 关系代数（Relational Algebra）是一种功能语言，它构成了SQL查询语言的理论基础
* 关系代数由一组谓词组成，这些谓词将一个或两个关系作为输入并产生一个新的关系作为结果 

| Symbol  |  Operator |
| ----:  |  :---- |
| σ  |  Select |
| Π  |  Project |
| x  |  Cartesian Product |
| ⋈  |  Join |
| ∪  |  Union |
| ∩  |  Intersection |
| –  |  Set Difference |
| ←  |  Assignment |
| ρ  |  Rename |

## σ - 选择（Select）

* 选择满足给定条件的元组
* 格式: σ <sub>p</sub> \(r\)，其中p称为选择谓词，r是关系名称
  * 例：选择instructor关系在“Physics” dept.中的元组
  * 查询： σ <sub>dept_name=“Physics”</sub> (instructor)
* 可以在选择谓词中使用=，≠，>，≥，<，≤
* 可以通过使用连接词将多个谓词组合为更大的谓词：∧（与），∨（或），￢（非）
  * 例：找到salary超过$90,000的Physics instructors
  * 查询： σ <sub>dept_name=“Physics” ∧ salary>90,000</sub> (instructor)
* 选择谓词可以包括两个属性之间的比较
  * 例：查找dept. name与building name相同的所有dept.
  * 查询： σ <sub>dept_name=building</sub> (department)

## Π - 投影（Project）

* 一元运算，返回其参数关系，但保留某些属性
* 格式: Π <sub>A<sub>1</sub>,A<sub>2</sub>,A<sub>3</sub> ….A<sub>k</sub></sub> \(r\)，其中 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub> 是属性名称，r是关系名称
* 结果定义为通过删除未列出的列获得的k列的关系
* 由于关系已设置，因此从结果中删除了重复的行
* 查询： Π <sub>ID, name, salary</sub> (instructor)

## 组合

* 关系代数运算的结果是关系，因此关系代数运算可以一起组成关系代数表达式
* 例：查找Physics dept.所有instructor的name
* 查询：Π <sub>name</sub> ( σ <sub>dept_name =“Physics”</sub> (instructor) )
* 没有给出关系的名称作为Π的参数，而是给出了计算关系的表达式

## x - 笛卡尔积（Cartesian-Product）

* 组合来自任何两个关系的信息
  * 例：关系instructor和teaches的笛卡尔积为instructor x teaches
  * 从每对可能的元组中构造一个结果元组：一个来自instructor关系，一个来自teaches关系
* 由于instructor ID出现在两个关系中，因此我们通过在属性上附加关系的名称来区分这些属性
  * instructor.ID
  * teaches.ID

## ⋈ - 连接（Join）

* instructor x teaches将instructor和teaches的全部元组联系起来，但结果中包含很多并没有授课的instructor。为了仅获取与instructor及其所授课程相关的元组，可以这样写：
  * σ <sub>instructor.id=teaches.id</sub> (instructor x teaches)
* 连接谓词是选择谓词和笛卡尔积谓词的组合
* 考虑关系 r \(R\) and s (S)
  * 假设“theta”是模式R “union” S中属性的谓词。连接谓词r ⋈<sub>θ</sub> s的定义是σ<sub>θ</sub> (r x s)
  * 因此，σ <sub>instructor.id=teaches.id</sub> (instructor x teaches) )可以等效地写为instructor ⋈ <sub>Instructor.id=teaches.id</sub> teaches

## ∪ - 并（Union）

* 合并两个关系
* 格式： r ∪ s
* r ∪ s有效的条件：
  * r, s必须具有相同的元数（相同数量的属性）
  * 属性域必须兼容（例：r的第二列与s的第二列处理相同类型的值）
* 例：查找2017年秋季学期或2018年春季学期或两者兼而有之的所有课程
  * Π <sub>course_id</sub> ( σ <sub>semester=“Fall” Λ year=2017</sub> (section) ) ∪ Π <sub>course_id</sub> ( σ <sub>semester=“Spring” Λ year=2018</sub> (section) )

## ∩ - 交（Intersection）

* 找到两个关系中的元组
* 格式： r ∩ s
* 条件：
  * r, s必须具有相同的元数
  * 属性域必须兼容
* 例：查找在2017年秋季以及2018年春季学期教授的所有课程的集合
  * Π <sub>course_id</sub> ( σ <sub>semester=“Fall” Λ year=2017</sub> (section) ) ∩ Π <sub>course_id</sub> ( σ <sub>semester=“Spring” Λ year=2018</sub> (section) )

## - - 差（Difference）

* 找到处于一种关系而不在另一种关系的元组
* 格式：r – s
* 条件：
  * r, s必须具有相同的元数
  * 属性域必须兼容
* 例：查找2017年秋季学期教授，但不在2018春季学期教授的所有课程
  * Π <sub>course_id</sub> ( σ <sub>semester=“Fall” Λ year=2017</sub> (section) ) – Π <sub>course_id</sub> ( σ <sub>semester=“Spring” Λ year=2018</sub> (section) )

## ← - 分配（Assignment）

* 有时可以通过将关系代数表达式的一部分分配给临时关系变量来方便地编写关系代数表达式
* 其工作方式类似于编程语言中的赋值
* 例：找到“Physics”和“Music”部门的所有讲师。
  * Physics ← σ <sub>dept_name=“Physics”</sub> (instructor)
  * Music ← σ <sub>dept_name=“Music”</sub> (instructor)
  * Physics ∪ Music
* 通过赋值操作，可以将查询编写为一个顺序程序，该程序由一系列赋值和一个表达式组成，该表达式的值显示为查询的结果

## ρ - 重命名（Rename）

* 关系代数表达式的结果没有可用来引用它们的名称。为此，提供了重命名
* 表达式ρ <sub>x</sub> (E)返回名称为x的表达式E的结果
* 另一种形式：ρ <sub>x(A1,A2, .. An)</sub> (E)

## 等效查询（Equivalent Queries）

* 用关系代数编写查询的方法有多种
* 例：查找有关Physics dept.的instructor所教课程的salary超过90,000的信息
  * 查询1: σ <sub>dept_name=“Physics” ∧ salary>90,000</sub> (instructor)
  * 查询2: σ <sub>dept_name=“Physics”</sub> ( σ <sub>salary>90.000</sub> (instructor) )
  * 这两个查询不相同，但是它们是等效的，它们在任何数据库上都给出相同的结果
* 例：查找有关Physics dept.的instructor的teaches的信息
  * 查询1: σ <sub>dept_name=“Physics”</sub> (instructor ⋈ <sub>instructor.ID=teaches.ID</sub> teaches)
  * 查询2: ( σ <sub>dept_name=“Physics”</sub> (instructor) ) ⋈ <sub>instructor.ID=teaches.ID</sub> teaches
  * 这两个查询不相同，但是它们是等效的，它们在任何数据库上都给出相同的结果







